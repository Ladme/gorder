// Released under MIT License.
// Copyright (c) 2024 Ladislav Bartos

//! This module contains the implementation of the `gorder` binary.

use clap::Parser;
use colored::Colorize;
use gorder::{errors::ConfigError, prelude::Analysis, GORDER_VERSION};

#[derive(Parser, Debug)]
#[command(
    author,
    version,
    about,
    long_about = "Calculate order parameters for any atomistic or coarse grained system."
)]
pub struct Args {
    #[arg(
        help = "Config yaml file",
        long_help = "Configuration yaml file specifying the analysis options."
    )]
    pub config: String,

    #[arg(
        long = "silent",
        action,
        help = "Suppress standard output",
        default_value_t = false,
        long_help = "Suppress all standard output generated by the 'gorder' program, except for error messages.
This option can also be specified in the configuration file."
    )]
    pub silent: bool,

    #[arg(
        long = "overwrite",
        action,
        help = "Overwrite existing files and directories with the same name",
        default_value_t = false,
        long_help = "Overwrite existing files and directories with the same name as the output. No backup copies will be created.
This option can also be specified in the configuration file."
    )]
    pub overwrite: bool,
}

/// Get arguments, parse input file, run the analysis and write the results.
/// Returns `true` if run successfully, else returns `false`.
pub(crate) fn run() -> bool {
    let args = Args::parse();

    colog::init();

    let mut analysis = match Analysis::from_file(&args.config) {
        Ok(x) => x,
        Err(e) => {
            log::error!("{}", e);
            return false;
        }
    };

    // yaml output must always be specified in the config file for the application
    if analysis.output_yaml().is_none() {
        log::error!("{}", ConfigError::NoYamlOutput(args.config.clone()));
        return false;
    }

    if !analysis.silent() {
        analysis.set_silent(args.silent);
    }

    if !analysis.overwrite() {
        analysis.set_overwrite(args.overwrite);
    }

    let silent = analysis.silent();

    if silent {
        log::set_max_level(log::LevelFilter::Error);
    } else {
        let header = format!(">>> GORDER v{} <<<", GORDER_VERSION).bold();
        println!("\n{}\n", header);
        log::info!("Read config file '{}'.", args.config);
    }

    let result = analysis.run();

    if let Err(e) = result {
        log::error!("{}", e);
        display_result(false, silent);
        return false;
    }

    // write the results into an output file
    if let Err(e) = result.unwrap().write() {
        log::error!("{}", e);
        display_result(false, silent);
        return false;
    }

    display_result(true, silent);
    true
}

#[inline(always)]
fn display_result(result: bool, silent: bool) {
    if silent {
        return;
    }

    match result {
        true => {
            let prefix = format!(
                "{}{}{}",
                "[".to_string().blue().bold(),
                "✔".to_string().bright_green().bold(),
                "]".to_string().blue().bold()
            );
            let message = "ANALYSIS COMPLETED".to_string().bright_green().bold();
            println!("{} {}\n", prefix, message);
        }
        false => {
            let prefix = format!(
                "{}{}{}",
                "[".to_string().blue().bold(),
                "✖".to_string().red().bold(),
                "]".to_string().blue().bold()
            );
            let message = "ANALYSIS FAILED".to_string().red().bold();
            println!("{} {}\n", prefix, message);
        }
    }
}
