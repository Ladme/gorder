// Released under MIT License.
// Copyright (c) 2024-2025 Ladislav Bartos

//! Structures and methods for storing and accessing dynamic membrane normals.

use std::{
    fs::File,
    io::{BufWriter, Write},
    path::Path,
};

use getset::Getters;
use groan_rs::prelude::Vector3D;
use indexmap::IndexMap;

use crate::{
    errors::WriteError,
    prelude::AAOrderResults,
    presentation::{OutputFormat, Presenter, YamlPresenter},
    GORDER_VERSION, PANIC_MESSAGE,
};

#[derive(Debug, Clone, Getters)]
pub struct NormalsData {
    /// Indices of trajectory frames for which leaflet assignment was performed with the first analyzed frame having the index 1.
    #[getset(get = "pub")]
    frames: Vec<usize>,
    /// Membrane normals calculated for each lipid and each analyzed frame.
    normals: IndexMap<String, Vec<Vec<Vector3D>>>,
}

impl NormalsData {
    /// Initialize the NormalsData structure.
    /// - `n_analyzed_frames` is the total number of analyzed frames
    pub(super) fn new(step: usize, n_analyzed_frames: usize) -> Self {
        // generate the analyzed frame indices
        let frames: Vec<usize> = std::iter::successors(Some(1), |prev| Some(prev + step))
            .take(n_analyzed_frames)
            .collect();

        Self {
            frames,
            normals: IndexMap::new(),
        }
    }

    /// Get membrane normals for a lipid type `name`.
    /// Returns `None` if no normals for the lipid type could be found.
    #[inline]
    pub fn get_molecule(&self, name: &str) -> Option<&Vec<Vec<Vector3D>>> {
        self.normals.get(name)
    }

    /// Export the collected membrane normals into the output file.
    pub fn export(
        &self,
        filename: &impl AsRef<Path>,
        trajectories: &[String],
        overwrite: bool,
    ) -> Result<(), WriteError> {
        // the type of presenter does not matter in this case
        let file_status = YamlPresenter::<AAOrderResults>::try_backup(filename, overwrite)?;
        let file = File::create(filename.as_ref())
            .map_err(|_| WriteError::CouldNotCreateFile(Box::from(filename.as_ref())))?;
        let mut writer = BufWriter::new(file);

        self.write_header(&mut writer, trajectories)?;
        self.write_data(&mut writer)?;

        file_status.info_custom(
            OutputFormat::YAML,
            filename.as_ref().to_str().expect(PANIC_MESSAGE),
            "membrane normals",
        );

        Ok(())
    }

    /// Write the header for the leaflet classification file.
    fn write_header(
        &self,
        writer: &mut impl Write,
        trajectory: &[String],
    ) -> Result<(), WriteError> {
        if trajectory.len() == 1 {
            write_result!(
                writer,
                "# Membrane normals file generated by 'gorder v{}' using a trajectory file '{}'.\n",
                GORDER_VERSION,
                trajectory.first().expect(PANIC_MESSAGE)
            );
        } else {
            write_result!(
                writer,
                "# Membrane normals file generated by 'gorder v{}' using trajectory files '{}'.\n",
                GORDER_VERSION,
                trajectory.join(" ")
            );
        }

        Ok(())
    }

    /// Write the leaflet classification data into the output.
    fn write_data(&self, writer: &mut impl Write) -> Result<(), WriteError> {
        for (lipid, normals) in self.normals.iter() {
            write_result!(writer, "{}:\n", lipid);
            for (frame_data, frame_index) in normals.iter().zip(self.frames.iter()) {
                write_result!(writer, "# Frame index {}\n", frame_index);
                write_result!(
                    writer,
                    "  - [{}]\n",
                    frame_data
                        .iter()
                        .map(Self::format_vector)
                        .collect::<Vec<String>>()
                        .join(",")
                );
            }
        }

        Ok(())
    }

    fn format_vector(vec: &Vector3D) -> String {
        if vec.x.is_nan() && vec.y.is_nan() && vec.z.is_nan() {
            return format!("[{:9},{:9},{:9}]", ".nan", ".nan", ".nan");
        }

        if !vec.x.is_nan() && !vec.y.is_nan() && !vec.z.is_nan() {
            return format!("[{:9.6 },{:9.6 },{:9.6 }]", vec.x, vec.y, vec.z);
        }

        unreachable!("FATAL GORDER ERROR | NormalsData::format_vector | Either all or no fields of Vector3D should be NaN (`{:?}`) {}", vec, PANIC_MESSAGE);
    }

    /// Add membrane normals for a single lipid type into the structure.
    #[inline]
    pub(super) fn add_molecule_type(&mut self, name: &str, normals: Vec<Vec<Vector3D>>) {
        // defensive check that the number of frames in `normals` matches the expected number of frames
        assert!(
            normals.len() == self.frames.len(),
            "FATAL GORDER ERROR | NormalsData::add_molecule_type | The `normals` vector contains an unexpected number of frames."
        );

        self.normals.insert(name.to_owned(), normals);
    }

    /// Returns `true` if no normals have been collected.
    #[inline]
    pub(super) fn is_empty(&self) -> bool {
        self.normals.is_empty()
    }
}
